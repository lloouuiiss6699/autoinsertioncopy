<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Autoinsertion Virtual Gallery</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    /* Offscreen canvases are still renderable */
    canvas.wall-canvas {
      position: absolute;
      left: -9999px;
      top: -9999px;
    }
  </style>
</head>
<body>

<a-scene background="color: #111">
  <!-- Lighting -->
  <a-entity light="type: ambient; color: #666"></a-entity>
  <a-entity light="type: directional; color: #fff; intensity: 0.8" position="0 4 4"></a-entity>

  <!-- Camera -->
  <a-entity position="0 1.6 6">
    <a-camera look-controls></a-camera>
  </a-entity>

  <!-- Floor -->
  <a-plane rotation="-90 0 0" width="20" height="20" color="#222"></a-plane>

  <!-- Gallery walls -->
  <a-plane id="wall1" position="0 2 -5" rotation="0 0 0" width="10" height="4"></a-plane>
  <a-plane id="wall2" position="5 2 0" rotation="0 -90 0" width="10" height="4"></a-plane>
  <a-plane id="wall3" position="0 2 5" rotation="0 180 0" width="10" height="4"></a-plane>
  <a-plane id="wall4" position="-5 2 0" rotation="0 90 0" width="10" height="4"></a-plane>
</a-scene>

<script>
const overlaySrc = 'mee.png'; // make sure mee.png is in the same folder
const wallIds = ['wall1','wall2','wall3','wall4'];

function getRandomImage() {
  const width = 500 + Math.floor(Math.random()*300);
  const height = 400 + Math.floor(Math.random()*200);
  return { src: `https://picsum.photos/${width}/${height}?random=${Math.random()}`, width, height };
}

function getRandomRotation() { return Math.random() * 30 - 15; }
function getRandomScale() { return 0.9 + Math.random() * 0.2; }

function createWallCollage(wallId) {
  const canvas = document.createElement('canvas');
  canvas.width = 800;
  canvas.height = 400;
  canvas.className = 'wall-canvas';
  document.body.appendChild(canvas); // must be in DOM for A-Frame

  const ctx = canvas.getContext('2d');

  const wallEl = document.getElementById(wallId);
  wallEl.setAttribute('material', 'src', canvas);

  function addSingleImage() {
    const imgData = getRandomImage();
    const bg = new Image();
    bg.crossOrigin = "Anonymous";
    bg.src = imgData.src;

    bg.onload = () => {
      const scale = getRandomScale();
      const width = bg.naturalWidth * scale;
      const height = bg.naturalHeight * scale;

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const offsetX = Math.floor(Math.random() * 400 - 200);
      const offsetY = Math.floor(Math.random() * 300 - 150);
      const x = centerX + offsetX - width/2;
      const y = centerY + offsetY - height/2;

      // Draw background with rotation
      ctx.save();
      ctx.translate(x + width/2, y + height/2);
      ctx.rotate(getRandomRotation() * Math.PI/180);
      ctx.drawImage(bg, -width/2, -height/2, width, height);
      ctx.restore();

      // Overlay
      const overlay = new Image();
      overlay.src = overlaySrc;
      overlay.onload = () => {
        const overlayWidth = 120;
        const marginX = width*0.2;
        const marginY = height*0.2;
        const overlayMaxX = width - overlayWidth - 2*marginX;
        const overlayMaxY = height - overlayWidth - 2*marginY;
        const ox = x + marginX + Math.random()*overlayMaxX;
        const oy = y + marginY + Math.random()*overlayMaxY;

        ctx.save();
        ctx.translate(ox + overlayWidth/2, oy + overlayWidth/2);
        ctx.rotate(getRandomRotation() * Math.PI/180);
        ctx.drawImage(overlay, -overlayWidth/2, -overlayWidth/2, overlayWidth, overlayWidth);
        ctx.restore();

        // Mark canvas for A-Frame to update texture
        if (wallEl.getObject3D('mesh')) {
          wallEl.getObject3D('mesh').material.map.needsUpdate = true;
        }
      };

      // Schedule next image
      setTimeout(addSingleImage, 1000 + Math.random()*300);
    };
  }

  addSingleImage();
  return canvas;
}

// Initialize all walls
wallIds.forEach(id => createWallCollage(id));
</script>

</body>
</html>
